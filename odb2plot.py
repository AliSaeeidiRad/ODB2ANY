"""
ODB2PLOT: A tool for plotting ABAQUS Output Database (ODB) results.

This module provides functionality to plot history outputs and field outputs
from JSON files generated by ODB2JSON. It supports customizable plotting options
through configuration files and command-line arguments.

Features:
- Plot history outputs with customizable line styles and markers
- Plot field outputs with range visualization
- Support for multiple output types (stress, strain, displacement, etc.)
- Configurable plot aesthetics (colors, sizes, labels, etc.)
- CSV export of plotted data for furthur customizations

Author: Ali Saeedi Rad
License: MIT License
Version: 1.0.0
Date: September 2025
Repository: https://github.com/AliSaeeidiRad/ODB2ANY
"""

import os
import json
import argparse
from dataclasses import dataclass, asdict, field
from typing import List, Tuple, Dict, Any, Optional, Union

import numpy as np
import matplotlib.pyplot as plt


@dataclass
class HistoryOutputPlotConfig:
    """Configuration class for history output plots.

    This class defines all the customizable parameters for plotting ABAQUS history output data.
    All parameters have sensible defaults but can be overridden through a JSON configuration file.

    Attributes:
        figsize (Tuple[int, int]): Figure size in inches (width, height).
        plot_min_x (float): Minimum x-value for plot interpolation.
        plot_max_x (float): Maximum x-value for plot interpolation.
        plot_steps_x (int): Number of points for x-axis interpolation.
        plot_color (str): Color of the plotted line (matplotlib color name or hex code).
        plot_linewidth (float): Width of the plotted line.
        plot_linestyle (str): Style of the plotted line ('-', '--', ':', '-.').
        plot_label (str): Label for the plotted data in the legend.
        grid (bool): Whether to show grid lines.
        grid_linestyle (str): Style of grid lines ('--', ':', '-.').
        grid_alpha (float): Transparency of grid lines (0.0 to 1.0).
        xticks_min (float): Minimum value for x-axis ticks.
        xticks_max (float): Maximum value for x-axis ticks.
        xticks_num (int): Number of ticks on x-axis.
        xlim_min (float): Lower limit for x-axis.
        xlim_max (float): Upper limit for x-axis.
        yticks_min (float): Minimum value for y-axis ticks.
        yticks_max (float): Maximum value for y-axis ticks.
        yticks_num (int): Number of ticks on y-axis.
        ylim_min (float): Lower limit for y-axis.
        ylim_max (float): Upper limit for y-axis.
        plot_loc (str): Legend location ('upper right', 'lower left', etc.).
        plot_fontsize (float): Font size for plot text elements.
        plot_x_label (str): Label for x-axis.
        plot_y_label (str): Label for y-axis.
        title (str): Plot title.
    """

    figsize: Tuple[int, int] = (10, 10)
    plot_min_x: float = 0.0
    plot_max_x: float = 60.0
    plot_steps_x: int = 60
    plot_color: str = "royalblue"
    plot_linewidth: float = 2.5
    plot_linestyle: str = "-"
    plot_label: str = "Result"
    grid: bool = True
    grid_linestyle: str = "--"
    grid_alpha: float = 0.5
    xticks_min: float = 0.0
    xticks_max: float = 60.0
    xticks_num: int = 11
    xlim_min: float = 0.0
    xlim_max: float = 60.0
    yticks_min: float = 0.0
    yticks_max: float = 100.0
    yticks_num: int = 11
    ylim_min: float = 0.0
    ylim_max: float = 100.0
    plot_loc: str = "upper right"
    plot_fontsize: float = 12.0
    plot_x_label: str = "X"
    plot_y_label: str = "Y"
    title: str = "PLOT"


@dataclass
class FieldOutputPlotConfig:
    """Configuration class for field output plots.

    This class defines all the customizable parameters for plotting ABAQUS field output data.
    Field output plots include a filled range area showing min/max values and a mean value line.
    All parameters have sensible defaults but can be overridden through a JSON configuration file.

    Attributes:
        figsize (Tuple[int, int]): Figure size in inches (width, height).
        fill_between_color (str): Color for the min/max range area.
        fill_between_alpha (float): Transparency for the range area (0.0 to 1.0).
        fill_between_label (str): Label for the range area in the legend.
        plot_min_x (float): Minimum x-value for plot interpolation.
        plot_max_x (float): Maximum x-value for plot interpolation.
        plot_color (str): Color of the mean value line.
        plot_linewidth (float): Width of the mean value line.
        plot_linestyle (str): Style of the mean value line ('-', '--', ':', '-.').
        plot_label (str): Label for the mean value line in the legend.
        grid (bool): Whether to show grid lines.
        grid_linestyle (str): Style of grid lines ('--', ':', '-.').
        grid_alpha (float): Transparency of grid lines (0.0 to 1.0).
        xticks_min (float): Minimum value for x-axis ticks.
        xticks_max (float): Maximum value for x-axis ticks.
        xticks_num (int): Number of ticks on x-axis.
        xlim_min (float): Lower limit for x-axis.
        xlim_max (float): Upper limit for x-axis.
        yticks_min (float): Minimum value for y-axis ticks.
        yticks_max (float): Maximum value for y-axis ticks.
        yticks_num (int): Number of ticks on y-axis.
        ylim_min (float): Lower limit for y-axis.
        ylim_max (float): Upper limit for y-axis.
        plot_loc (str): Legend location ('upper right', 'lower left', etc.).
        plot_fontsize (float): Font size for plot text elements.
        plot_x_label (str): Label for x-axis.
        plot_y_label (str): Label for y-axis.
        title (str): Plot title.
    """

    figsize: Tuple[int, int] = (10, 10)
    fill_between_color: str = "skyblue"
    fill_between_alpha: float = 0.4
    fill_between_label: str = "Range"
    plot_min_x: float = 0.0
    plot_max_x: float = 60.0
    plot_color: str = "royalblue"
    plot_linewidth: float = 2.5
    plot_linestyle: str = "-"
    plot_label: str = "Result"
    grid: bool = True
    grid_linestyle: str = "--"
    grid_alpha: float = 0.5
    xticks_min: float = 0.0
    xticks_max: float = 60.0
    xticks_num: int = 11
    xlim_min: float = 0.0
    xlim_max: float = 60.0
    yticks_min: float = 0.0
    yticks_max: float = 7.0
    yticks_num: int = 11
    ylim_min: float = 0.0
    ylim_max: float = 7.0
    plot_loc: str = "upper right"
    plot_fontsize: float = 12.0
    plot_x_label: str = "X"
    plot_y_label: str = "Y"
    title: str = "PLOT"


@dataclass
class PlotConfig:
    """Main configuration class that holds both history and field output plot settings.

    This class manages both HistoryOutputPlotConfig and FieldOutputPlotConfig instances
    and provides methods for saving/loading configurations from JSON files.

    Attributes:
        history_config (HistoryOutputPlotConfig): Configuration for history output plots.
        field_config (FieldOutputPlotConfig): Configuration for field output plots.
    """

    history_config: HistoryOutputPlotConfig = field(
        default_factory=lambda: HistoryOutputPlotConfig()
    )
    field_config: FieldOutputPlotConfig = field(
        default_factory=lambda: FieldOutputPlotConfig()
    )

    def save_to_json(self, filepath: str) -> None:
        """Save the current configuration to a JSON file.

        Args:
            filepath (str): Path where the JSON configuration file should be saved.
        """
        with open(filepath, "w") as f:
            json.dump(asdict(self), f, indent=4)

    @classmethod
    def from_json(cls, filepath: str) -> "PlotConfig":
        """Create a PlotConfig instance from a JSON file.

        Args:
            filepath (str): Path to the JSON configuration file.

        Returns:
            PlotConfig: A new PlotConfig instance with settings from the JSON file.

        Raises:
            FileNotFoundError: If the configuration file doesn't exist.
            json.JSONDecodeError: If the configuration file is not valid JSON.
        """
        with open(filepath, "r") as f:
            data = json.load(f)

        history_data = data.get("history_config", {})
        field_data = data.get("field_config", {})

        return cls(
            history_config=HistoryOutputPlotConfig(**history_data),
            field_config=FieldOutputPlotConfig(**field_data),
        )


def extract_headers_information_history_output(
    filename: str, output_dir: str
) -> List[str]:
    """Extract and save header information from a history output JSON file.

    This function reads a JSON file containing history output data, processes it to
    extract metadata about available outputs, and saves this information to a new file.

    Args:
        filename (str): Path to the history output JSON file.
        output_dir (str): Directory where the processed header information should be saved.

    Returns:
        List[str]: List of available history output variable names.

    Raises:
        FileNotFoundError: If the input file cannot be found.
        json.JSONDecodeError: If the input file is not valid JSON.
        TypeError: If the JSON file structure is not as expected.
        OSError: If there are issues creating the output directory.
    """
    if not os.path.exists(filename):
        raise FileNotFoundError(f"History output file not found: {filename}")

    try:
        with open(filename, "r") as f:
            ho = json.load(f)
    except json.JSONDecodeError as e:
        raise json.JSONDecodeError(
            f"Invalid JSON in history output file: {filename}. Error: {str(e)}",
            e.doc,
            e.pos,
        )

    if not isinstance(ho, dict):
        raise TypeError(f"Expected dictionary in {filename}, got {type(ho)}")

    result = {key: len(value) for key, value in ho.items()}

    output_dir = os.path.join(
        os.path.dirname(filename) if output_dir == "" else output_dir,
        "ODB2PLOT",
        "HEADERS",
    )

    try:
        os.makedirs(output_dir)
    except:
        print("Directory Already Exists.")

    fname = os.path.join(
        output_dir,
        os.path.basename(filename),
    )
    with open(fname, "w") as f:
        json.dump(result, f, indent=4)

    print('File Exported: "{}"'.format(os.path.abspath(fname)))

    return list(result.keys())


def extract_headers_information_field_output(
    filename: str, output_dir: str
) -> Dict[str, Any]:
    """Extract and save header information from a field output JSON file.

    This function processes a field output JSON file to extract metadata about available
    analysis steps, frames, and output variables. The extracted information is saved
    to a new file in a structured format.

    Args:
        filename (str): Path to the field output JSON file.
        output_dir (str): Directory where the processed header information should be saved.

    Returns:
        Dict[str, Any]: Dictionary containing:
            - steps: List of available analysis step names
            - frames: Dictionary mapping steps to their frame indices
            - field_options: Nested dictionary of available field outputs per step and frame

    Raises:
        FileNotFoundError: If the input file cannot be found.
        json.JSONDecodeError: If the input file is not valid JSON.
    """
    fo = json.load(open(filename))
    steps = list(fo.keys())
    frames = {}

    for step in steps:
        frames[step] = [f"frame_{i}" for i in range(len(list(fo[step].keys())))]

    field_options = {}
    for step in steps:
        field_options[step] = {}
        for frame in frames[step]:
            field_options[step].update({frame: list(fo[step][frame].keys())})

    result = {
        "steps": steps,
        "frames": frames,
        "field_options": field_options,
    }

    output_dir = os.path.join(
        os.path.dirname(filename) if output_dir == "" else output_dir,
        "ODB2PLOT",
        "HEADERS",
    )

    try:
        os.makedirs(output_dir)
    except:
        print("Directory Already Exists.")

    fname = os.path.join(
        output_dir,
        os.path.basename(filename),
    )
    with open(fname, "w") as f:
        json.dump(
            result,
            f,
            indent=4,
        )

    print('File Exported: "{}"'.format(os.path.abspath(fname)))

    return result


def plot_history_output(
    filename: str,
    option: List[str],
    plot_config: PlotConfig,
    extension_plot: str,
    output_dir: str,
) -> None:
    """Create plots from history output data.

    This function reads history output data from a JSON file and creates customized plots
    based on the provided configuration. It supports multiple output types and saves both
    the plot image and the raw data in CSV format.

    Args:
        filename (str): Path to the history output JSON file.
        option (List[str]): List of keywords to identify the history output variable.
        plot_config (PlotConfig): Configuration object containing plot settings.
        extension_plot (str): File extension for the plot image (e.g., '.tiff', '.png').
        output_dir (str): Directory where plot and data files should be saved.

    Raises:
        FileNotFoundError: If the input file cannot be found.
        ValueError: If no matching output variable is found or if multiple matches are found.
        json.JSONDecodeError: If the input file is not valid JSON.

    Note:
        The function interpolates the data to a fixed number of points and applies the
        plotting settings from the plot_config object. Both the plot image and the raw
        data (in CSV format) are saved to the output directory.
    """
    ho = json.load(open(filename))

    history_options = extract_headers_information_history_output(filename, output_dir)

    related_history_options = []
    for _available_option in history_options:
        _must_add = []
        for _must_add_option in option:
            if _must_add_option.lower() in _available_option.lower():
                _must_add.append(True)
            else:
                _must_add.append(False)
        if all(_must_add):
            related_history_options.append(_available_option)

    selected_option = list(set(related_history_options))

    if len(selected_option) == 0:
        raise ValueError(
            f"There is no nominated history output for given keyword, please choose a better keyword to specify the desired history output. \n{history_options}"
        )
    if len(selected_option) > 1:
        raise ValueError(
            f"selected history output have multiple results, please choose a better keyword to specify the desired history output. \n{selected_option}"
        )

    selected_option = selected_option[0]

    print(f"Selected History Output: {selected_option}")

    fig = plt.figure(figsize=plot_config.history_config.figsize)

    ax = fig.add_subplot(1, 1, 1)

    x = np.linspace(
        plot_config.history_config.plot_min_x,
        plot_config.history_config.plot_max_x,
        plot_config.history_config.plot_steps_x,
    )
    y = np.interp(
        np.linspace(0, 1, plot_config.history_config.plot_steps_x),
        np.linspace(0, 1, len(ho[selected_option])),
        ho[selected_option],
    )

    ax.plot(
        x,
        y,
        color=plot_config.history_config.plot_color,
        linewidth=plot_config.history_config.plot_linewidth,
        linestyle=plot_config.history_config.plot_linestyle,
        label=plot_config.history_config.plot_label,
    )

    ax.grid(
        plot_config.history_config.grid,
        linestyle=plot_config.history_config.grid_linestyle,
        alpha=plot_config.history_config.grid_alpha,
    )

    ax.set_xticks(
        np.linspace(
            plot_config.history_config.xticks_min,
            plot_config.history_config.xticks_max,
            plot_config.history_config.xticks_num,
        )
    )
    ax.set_xlim(
        plot_config.history_config.xlim_min,
        plot_config.history_config.xlim_max,
    )

    ax.set_yticks(
        np.linspace(
            plot_config.history_config.yticks_min,
            plot_config.history_config.yticks_max,
            plot_config.history_config.yticks_num,
        )
    )
    ax.set_ylim(
        plot_config.history_config.ylim_min,
        plot_config.history_config.ylim_max,
    )

    ax.tick_params(axis="both", which="major", labelsize=12)

    ax.legend(
        loc=plot_config.history_config.plot_loc,
        fontsize=plot_config.history_config.plot_fontsize,
        frameon=True,
    )

    ax.set_xlabel(plot_config.history_config.plot_x_label)
    ax.set_ylabel(plot_config.history_config.plot_y_label)
    ax.set_title(plot_config.history_config.title)

    output_dir = os.path.join(
        os.path.dirname(filename) if output_dir == "" else output_dir,
        "ODB2PLOT",
        "PLOTS",
        "HISTORY",
    )

    try:
        os.makedirs(output_dir)
    except:
        print("Directory Already Exists.")

    fname = os.path.join(
        output_dir,
        os.path.basename(filename).replace(
            ".json",
            "_{}{}".format(
                selected_option.replace(
                    "/",
                    "-against-",
                ),
                extension_plot,
            ),
        ),
    )
    fig.savefig(fname)

    np.savetxt(
        fname.replace(extension_plot, ".csv"),
        np.column_stack((x, y)),
        delimiter=",",
        header="x,y",
        comments="",
        fmt="%.4f",
    )

    print(f"Plot saved into: {os.path.abspath(fname)}")


def smooth_specific_range(
    data: np.ndarray,
    start_idx: Union[int, np.integer],
    end_idx: Union[int, np.integer],
    window_size: int = 5,
) -> np.ndarray:
    """Apply moving average smoothing to a specific range of data.

    This function applies a simple moving average filter to a section of the input data
    while leaving the rest unchanged. It uses edge padding to handle boundary effects.

    Args:
        data (np.ndarray): Input data array to smooth.
        start_idx (int): Starting index of the range to smooth.
        end_idx (int): Ending index of the range to smooth.
        window_size (int, optional): Size of the moving average window. Defaults to 5.

    Returns:
        np.ndarray: Array with smoothed values in the specified range.
    """
    smoothed_data = data.copy()
    section = data[start_idx:end_idx]

    pad_width = window_size // 2
    padded_section = np.pad(section, pad_width, mode="edge")

    smoothed_section = np.convolve(
        padded_section, np.ones(window_size) / window_size, mode="valid"
    )

    smoothed_data[start_idx:end_idx] = smoothed_section
    return smoothed_data


def post_process(
    re: np.ndarray,
    min_x: Union[float, np.floating],
    max_x: Union[float, np.floating],
    transpose: bool = False,
    filter_zeros: bool = False,
) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, float]:
    """Process field output data for plotting.

    This function takes raw field output data and processes it for visualization by:
    1. Computing min, max, and mean values across all frames
    2. Smoothing the data in the non-boundary regions
    3. Computing the area between max and min curves

    Args:
        re (np.ndarray): Raw field output data array (n_points x n_frames).
        min_x (float): Minimum x-value for the plot range.
        max_x (float): Maximum x-value for the plot range.

    Returns:
        Tuple containing:
        - np.ndarray: data
        - np.ndarray: X-axis values (linspace)
        - np.ndarray: Smoothed minimum values
        - np.ndarray: Smoothed maximum values
        - np.ndarray: Smoothed mean values
        - float: Area between max and min curves
    """
    if filter_zeros:  # NOTE: use this option when you know what you are doing
        filtered_columns = []
        for i in range(re.shape[1]):
            dd = re[:, i]
            if not np.all(dd == 0):
                filtered_columns.append(dd)
        filtered_columns = np.array(filtered_columns).T if filtered_columns else re
    else:
        filtered_columns = re
    re = np.array(filtered_columns)

    if transpose:
        re = re.T  # NOTE: by default you would not need it, but it occur in some cases

    min_vals = np.min(re, axis=-1)
    max_vals = np.max(re, axis=-1)
    mean_vals = np.mean(re, axis=-1)

    num_steps = len(min_vals)
    linspace = np.linspace(
        min_x,
        max_x,
        num_steps,
    )

    smooth_start_degree = min_x + 1
    smooth_end_degree = max_x - 1

    start_idx = np.searchsorted(
        linspace,
        smooth_start_degree,
    )
    end_idx = np.searchsorted(
        linspace,
        smooth_end_degree,
    )

    smoothed_min = smooth_specific_range(
        min_vals,
        start_idx,
        end_idx,
        window_size=5,
    )
    smoothed_max = smooth_specific_range(
        max_vals,
        start_idx,
        end_idx,
        window_size=5,
    )
    smoothed_mean = smooth_specific_range(
        mean_vals,
        start_idx,
        end_idx,
        window_size=5,
    )

    area_1 = np.trapezoid(
        smoothed_max,
        x=linspace,
    )
    area_2 = np.trapezoid(
        smoothed_min,
        x=linspace,
    )
    area = area_1 - area_2

    return filtered_columns, linspace, smoothed_min, smoothed_max, smoothed_mean, area


def plot_field_output(
    filename: str,
    option: List[str],
    steps: Union[Dict[str, List[int]], str],
    plot_config: PlotConfig,
    extension_plot: str,
    data_key: str,
    output_dir: str,
    transpose: bool = False,
    filter_zeros: bool = False,
) -> None:
    """Create plots from field output data with range visualization.

    This function processes field output data from a JSON file and creates plots showing
    the range and mean of the selected field variable across different frames. It supports
    data filtering, smoothing, and customizable plot settings.

    Args:
        filename (str): Path to the field output JSON file.
        option (List[str]): Keywords to identify the field output variable.
        steps (Union[Dict[str, List[int]], str]): Either a dictionary mapping step names
            to frame indices, or "*" to include all frames.
        plot_config (PlotConfig): Configuration object containing plot settings.
        extension_plot (str): File extension for the plot image (e.g., '.tiff', '.png').
        data_key (str): Key to access the data within the JSON structure.
        output_dir (str): Directory where plot and data files should be saved.

    Raises:
        FileNotFoundError: If the input file cannot be found.
        ValueError: If no matching output variable is found, multiple matches are found,
            or if the data structure is unexpected.
        json.JSONDecodeError: If the input file is not valid JSON.

    Note:
        The function performs data smoothing in non-boundary regions and creates a plot
        showing the range of values (as a filled area) and the mean value (as a line).
        Both the plot image and the processed data are saved to CSV format.
    """
    fo = json.load(open(filename))

    field_options = extract_headers_information_field_output(filename, output_dir)

    steps_dict: Dict[str, List[int]]
    if isinstance(steps, str) and steps == "*":
        steps_dict = {
            k: list(range(len(v))) for k, v in field_options["frames"].items()
        }
    elif isinstance(steps, dict):
        steps_dict = steps
    else:
        raise ValueError(
            "Steps must be either '*' or a dictionary mapping steps to frames"
        )

    step = list(steps_dict.keys())[0]
    frames = [f"frame_{i}" for i in steps_dict[step]]

    related_field_options = []
    for frame in frames:
        for _available_option in field_options["field_options"][step][frame]:
            _must_add = []
            for _must_add_option in option:
                if _must_add_option.lower() in _available_option.lower():
                    _must_add.append(True)
                else:
                    _must_add.append(False)
            if all(_must_add):
                related_field_options.append(_available_option)

    selected_option = list(set(related_field_options))

    if len(selected_option) == 0:
        raise ValueError(
            f"There is no nominated history output for given keyword, please choose a better keyword to specify the desired history output. \n{field_options}"
        )
    if len(selected_option) > 1:
        raise ValueError(
            f"selected history output have multiple results, please choose a better keyword to specify the desired history output. \n{selected_option}"
        )

    selected_option = selected_option[0]

    print(f"Selected Field Output: {selected_option}")

    re = []
    for frame_idx in range(len(frames)):
        data = fo[step][f"frame_{frame_idx}"][selected_option][0][data_key]

        if isinstance(data, dict):
            keys_in_data = list(data.keys())
            if len(keys_in_data) > 1:
                raise ValueError(f"There are multiple keys in data_key. ({data_key})")
            else:
                data = data[keys_in_data[0]]
        if not isinstance(data, list):
            raise ValueError(
                f"Data in data key must be a list not {type(data)}, ({data_key})"
            )

        data = np.array(data)

        if data.ndim > 2:
            raise ValueError("Data as an Unkown Shape. {}".format(data.shape))

        if data.ndim == 2 and data.shape[1] != 1:
            data = data.mean(axis=-1)

        if data.ndim == 2 and data.shape[1] == 1:
            data = data.ravel()

        re.append(data)

    re = np.stack(re, axis=-1).T

    print("Array Shape for Selected Field Output: {}".format(re.shape))
    print("Array Maximum for Each Frame: \n{}".format(re.max(-1)))
    print("Array Minimum for Each Frame: \n{}".format(re.min(-1)))
    print("Array Average for Each Frame: \n{}".format(re.mean(-1)))

    fig = plt.figure(figsize=plot_config.field_config.figsize)

    ax = fig.add_subplot(1, 1, 1)

    filtered_re, linspace, linspace_min, linspace_max, linspace_mean, area = (
        post_process(
            re,
            plot_config.field_config.plot_min_x,
            plot_config.field_config.plot_max_x,
            transpose,
            filter_zeros,
        )
    )

    ax.fill_between(
        linspace,
        linspace_min,
        linspace_max,
        color=plot_config.field_config.fill_between_color,
        alpha=plot_config.field_config.fill_between_alpha,
        label=plot_config.field_config.fill_between_label,
    )

    ax.plot(
        linspace,
        linspace_mean,
        color=plot_config.field_config.plot_color,
        linewidth=plot_config.field_config.plot_linewidth,
        linestyle=plot_config.field_config.plot_linestyle,
        label=plot_config.field_config.plot_label,
    )

    ax.grid(
        plot_config.field_config.grid,
        linestyle=plot_config.field_config.grid_linestyle,
        alpha=plot_config.field_config.grid_alpha,
    )

    ax.set_xticks(
        np.linspace(
            plot_config.field_config.xticks_min,
            plot_config.field_config.xticks_max,
            plot_config.field_config.xticks_num,
        )
    )
    ax.set_xlim(
        plot_config.field_config.xlim_min,
        plot_config.field_config.xlim_max,
    )

    ax.set_yticks(
        np.linspace(
            plot_config.field_config.yticks_min,
            plot_config.field_config.yticks_max,
            plot_config.field_config.yticks_num,
        )
    )
    ax.set_ylim(
        plot_config.field_config.ylim_min,
        plot_config.field_config.ylim_max,
    )

    ax.tick_params(axis="both", which="major", labelsize=12)

    ax.legend(
        loc=plot_config.field_config.plot_loc,
        fontsize=plot_config.field_config.plot_fontsize,
        frameon=True,
    )

    ax.set_xlabel(plot_config.field_config.plot_x_label)
    ax.set_ylabel(plot_config.field_config.plot_y_label)
    ax.set_title(plot_config.field_config.title)

    output_dir = os.path.join(
        os.path.dirname(filename) if output_dir == "" else output_dir,
        "ODB2PLOT",
        "PLOTS",
        "FIELD",
    )

    try:
        os.makedirs(output_dir)
    except:
        print("Directory Already Exists.")

    fname = os.path.join(
        output_dir,
        os.path.basename(filename).replace(
            ".json",
            "_{}{}".format(
                selected_option.replace(
                    "/",
                    "-against-",
                ),
                extension_plot,
            ),
        ),
    )
    fig.savefig(fname)

    np.savetxt(
        fname.replace(extension_plot, ".csv"),
        np.column_stack((linspace, linspace_min, linspace_mean, linspace_max)),
        delimiter=",",
        header="x,y_min,y_mean,y_max",
        comments="",
        fmt="%.4f",
    )

    print(f"Plot saved into: {os.path.abspath(fname)}")


def parse_arguments() -> argparse.Namespace:
    """Parse and validate command line arguments.

    Returns:
        argparse.Namespace: Parsed command line arguments.

    Example:
        To plot a history output:
        python odb2plot.py --history history_output.json --history-option RF1,RF2

        To plot a field output:
        python odb2plot.py --field field_output.json --field-option MISES --step "Step-1:0,1,2"

        To extract headers only:
        python odb2plot.py --field field_output.json --header
    """
    parser = argparse.ArgumentParser(
        prog="odb2plot",
        description="Plotting tool for ABAQUS ODB results processed by ODB2JSON",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    # Input file options
    input_group = parser.add_argument_group("Input Files")
    input_group.add_argument(
        "--history",
        type=str,
        metavar="FILE",
        help="Path to the history output JSON file from ODB2JSON",
    )
    input_group.add_argument(
        "--field",
        type=str,
        metavar="FILE",
        help="Path to the field output JSON file from ODB2JSON",
    )
    input_group.add_argument(
        "--plot-config",
        type=str,
        default="plot_config.json",
        metavar="FILE",
        help="Plot configuration JSON file (default: %(default)s)",
    )

    # Analysis options
    analysis_group = parser.add_argument_group("Analysis Options")
    analysis_group.add_argument(
        "--header",
        action="store_true",
        help="Extract and print JSON file headers only",
    )
    analysis_group.add_argument(
        "--step",
        nargs="+",
        metavar="STEP:FRAMES",
        help='Analysis steps and frames (e.g., "Step-1:0,1,2" or use "*" for all frames)',
    )
    analysis_group.add_argument(
        "--field-option",
        type=str,
        metavar="OPTION",
        help="Field output filters to plot (comma-separated: S_,PART-1-1)",
    )
    analysis_group.add_argument(
        "--history-option",
        type=str,
        metavar="OPTION",
        help="History output filters to plot (comma-separated: RF1_, PART-1-1)",
    )
    analysis_group.add_argument(
        "--data-key",
        type=str,
        default="data",
        metavar="KEY",
        help="Data location key in JSON structure (default: %(default)s)",
    )
    analysis_group.add_argument(
        "--transpose",
        action="store_true",
        help="Transpose data array before processing (useful when data dimensions need to be swapped)",
    )
    analysis_group.add_argument(
        "--filter-zeros",
        action="store_true",
        help="Filter out nodes with all zero values before processing",
    )

    # Output options
    output_group = parser.add_argument_group("Output Options")
    output_group.add_argument(
        "-o",
        "--output-dir",
        type=str,
        default="",
        metavar="DIR",
        help="Output directory for generated files (default: same as input)",
    )
    output_group.add_argument(
        "--extension-plot",
        type=str,
        default=".tiff",
        metavar="EXT",
        choices=[".tiff", ".png", ".jpg", ".pdf", ".svg"],
        help="Plot file extension (default: %(default)s)",
    )
    output_group.add_argument(
        "--area-unit",
        type=str,
        default="Degree.MPa",
        metavar="UNIT",
        help="Unit for area calculations (default: %(default)s)",
    )

    args = parser.parse_args()

    # Validate arguments
    if args.field is None and args.history is None:
        parser.error("At least one of --field or --history must be provided")

    if args.field_option and not args.step and not args.header:
        parser.error("--step is required when plotting field output")

    return args


def main() -> None:
    """Main entry point of the script.

    This function orchestrates the entire process of reading, processing, and plotting
    ABAQUS output data based on command-line arguments.

    Raises:
        FileNotFoundError: If required input files are not found.
        ValueError: If required arguments are missing or invalid.
        json.JSONDecodeError: If input JSON files are invalid.
    """
    args = parse_arguments()

    if args.history is None and args.field is None:
        raise FileNotFoundError(
            f"At least one of the history output or field output with json format must be passed."
        )

    if args.header:
        if args.history is not None:
            extract_headers_information_history_output(args.history, args.output_dir)
        if args.field is not None:
            extract_headers_information_field_output(args.field, args.output_dir)
    else:
        if not os.path.exists(args.plot_config):
            PlotConfig().save_to_json(args.plot_config)

        plot_config = PlotConfig.from_json(args.plot_config)

        if args.history_option:
            plot_history_output(
                args.history,
                args.history_option.split(","),
                plot_config,
                args.extension_plot,
                args.output_dir,
            )

        if args.field_option:
            if args.step is None:
                raise ValueError(
                    "--step is required when extracting field output data."
                )

            if args.step != ["*"]:
                steps = {}
                for item in args.step:
                    step_name, frame_str = item.split(":")
                    frame_indices = [int(f) for f in frame_str.split(",")]
                    steps[step_name] = frame_indices
            else:
                steps = "*"

            plot_field_output(
                args.field,
                args.field_option.split(","),
                steps,
                plot_config,
                args.extension_plot,
                args.data_key,
                args.output_dir,
                args.transpose,
                args.filter_zeros,
            )


if __name__ == "__main__":
    main()
